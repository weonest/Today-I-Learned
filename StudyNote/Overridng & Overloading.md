## 상속

### 상속의 정의와 장점

>   상속이란 기존의 클래스를 재사용하여 새로운 클래스를 작성하는 것.

*   장점
    *   보다 적은 양의 코드로 새로운 클래스를 작성할 수 있음
    *   코드를 공통으로 관리할 수 있기 때문에 코드의 추가 및 변경이 용이

>   이러한 장점들은 코드의 재사용성을 높이고 코드의 중복을 제거하여 프로그램의 생산성과 유지보수에 크게 기여한다.

*   자바에서의 상속 구현

새로 작성하고자 하는 클래스의 이름 뒤에 `extends`를 사용하여 상속 받고자 하는 클래스의 이름을 적어주면 된다.

```java
class Child extends Parent {}
```

이러한 두 클래스를 서로 상속 관계에 있다고 한다.



자손 클래스는 조상 클래스의 모든 멤버를 상속받으므로 항상 조상 클래스보다 많거나 같은 멤버를 갖는다. 따라서 상속은 조상 클래스를 확장한다는 의미로 해석할 수도 있다(키워드가 extends인 이유).

>   *   생성자와 초기화 블럭은 상속되지 않는다. 멤버만 상속된다.
>   *   자손 클래스의 멤버 개수는 조상 클래스보다 항상 많거나 같다.





```java
class Parent {}
class Child extends Parent {}
class Child2 extends Parent {}
class GrandChild extends Child {}
```

클래스 간의 관계에서는 조상-자손의 관계만 존재하지 **형제 관계는 존재하지 않는다.** 만약 Child 클래스와  Child2 클래스가 공통으로 가져야 하는 멤버가 추가된다면 각각의 클래스에 추가하는 것이 아니라 **조상 클래스인 Parent에 추가하는 것이 좋다.** 

이처럼 조상 클래스만 변경해도 모든 자손 클래스, 자손의 자손 클래스에까지 영향을 미치기 때문에 상속관계를 맺어주면 자손 클래스들의 **공통적인 부분**은 조상 클래스에서 관리하고, 자손 클래스는 자신에 정의된 멤버만 관리하면 되므로 코드가 적어져 관리가 쉬워진다.

>   클래스간의 상속 관계를 적절히 맺어 주는 것은 객체지향 프로그래밍에서 가장 중요한 부분이다.
>
>   
>
>   자손 클래스의 인스턴스를 생성하면 조상 클래스의 멤버와 자손 클래스의 멤버가 합쳐진 하나의 인스턴스로 생성된다.



### 클래스간의 관계 - 포함관계

>   상속 이외에도 클래스를 재사용하는 또 다른 방법이 잇는데 그것은 클래스간에 포함 관계를 맺어주는 것이다.

한 클래스의 멤버 변수로 다른 클래스 타입의 참조 변수를 선언하는 것을 뜻한다.

*   원을 표현하기 위한 클래스가 있다고 가정한다.

```java
class Circle {
    int x;		// 원점의 x좌표
    int y; 		// 원점의 y좌표
    int z;		// 반지름 (radius)
}
```

*   좌표상의 한 점을 다루기 위한 클래스가 있다고 가정한다.

```java
class Point {
    int x;		// x좌표
    int y;		// y좌표
}
```



Point 클래스를 재사용해서 Circle을 작성하면 다음과 같다. 

```java
class Circle {
    Point p;	// 원점
    int r;		// radius
}
```

>   이와 같이 한 클래스를 작성하는 데 다른 클래스를 멤버변수로 선언하여 포함시키는 것은 좋은 생각이다. 하나의 거대한 클래스를 작성하는 것보다 단위별로 여러 클래스를 작성한 다음, 이 단위 클래스들을 포함관계로 재사용하면 간결하고 손쉽게 클래스를 작성할 수 있다.



### 클래스간의 관계 결정하기

>   클래스를 작성하는데 있어서 `상속관계`를 맺어줄 것인지 `포함관계`를 맺어 줄 것인지 결정하는 것은 때때로 혼란스러울 때가 있다.

그럴 때는 `~은 ~이다(is - a)`와 `~은 ~을 가지고 있다(has - a)`를 넣어서 문장을 만들어보면 클래스 간의 관계가 명확해진다.

>   *   원은 점이다. - Circle is a Point
>   *   원은 점을 가지고 있다. - Circle has a Point

원은 원점과 반지름으로 구성되므로 두 번째 문장이 더 옳다는 것을 알 수 있다.

>*   is - a의 문장이 더 자연스럽다면 상속 관계를 적용한다.
>*   has - a의 문장이 더 자연스럽다면 포함 관계를 적용한다.



### 단일 상속(single inheritance)

다른 객체지향언어인 C++에서는 여러 조상 클래스로부터 상속받는 것이 가능한 `다중상속`을 허용하지만 자바는 오직 단일 상속만을 허용한다. 그래서 **둘 이상의 클래스를 상속받을 수 없다.**

다중 상속을 허용하면 여러 클래스롭부터 상속 받을 수 있기 대문에 복합적인 기능을 가진 클래스를 쉽게 작성할 수 있다는 장점이 있지만, 관계가 매우 복잡해지는 것, 서로 다른 클래스로부터 상속 받은 멤버간의 이름이 같은 경우 구별할 수 있는 방법이 없다는 단점을 가지고 있다.

>   단일 상속이 하나의 조상 클래스만을 가질 수 있기 때무에 다중 상속에 비해 불편한 점도 있지만, 클래스 간의 관계가 보다 명확해지고 코드를 더욱 신뢰할 수 있게 만들어 준다는 점에서 다중상속보다 유리하다. 



### Object 클래스

>   Object 클래스는 모든 클래스 상속계층도의 최상위에 잇는 조상클래스이다.
>
>   따로 다른 클래스를 상속 받지 않는 모든 클래스들은 모두 컴파일시 Object 클래스를 자동으로 상속받게 함으로써 이것을 가능하게 한다.



`toString()`이나 `equals(Object o)`와 같은 메서드를 따로 정의하지 않고도 사용할 수 있ㅅ었던 것은 이 메서드들이 Object 클래스에 정의된 것들이기 때문이다. 

Object 클래스에는 모든 인스턴스들이 가져야 할 기본적인 11개의 메서드가 정의되어 있다. 



## 오버라이딩(Overriding)

### 오버라이딩이란 ?

>   조상 클래스로부터 상속받은 메서드의 내용을 재정의하는 것을 오버라이딩이라고 한다. 상속받은 메서드를 그대로 사용하기도 하지만 자손 클래스 자신에 맞게 변경해야하는 경우가 많다. 이럴 때 조상의 메서드를 오버라이딩한다.



### 오버라이딩의 조건

>   자손 클래스에서 오버라이딩 하는 메서드는 조상 클래스의 메서드와
>
>   *   이름이 같아야 한다.
>   *   매개변수가 같아야 한다.
>   *   리턴 타입이 같아야 한다.

한마디로 요약하면 선언부가 조상과 완전히 일치해야 한다는 것이다. 다만 `접근제어자`와 `예외`는 제한된 조건 하에서 변경이 가능하다.

1.   접근 제어자는 조상 클래스의 메서드보다 범위를 좁게 지정할 수 없다.

     대부분의 경우 같은범위의 접근 제어자를 사용한다. 접근 제어자의 범위가 넓은 것에서 좁은 것으로 나열하면  `public` :arrow_right: `protected` :arrow_right: `default` :arrow_right: `private 이다.`

1.   조상클래스의 메서드보다 많은 수의 예외를 던질 수 없다.

     ```java
     public class Parent {
         void parentMethod() throws IOException, SQLException { ... }
     }
     
     public class Child extends Parent { 
         @Override
         void parentMethod() throws IOException { ... }	
     }
     ```

     Child 클래스는 부모인 Parent 클래스가 던지는 예외 보다 적은 수의 예외를 던진다. 하지만

     ```java
     public class Child extends Parent {
         @Override
         void parentMethod() throws Exception { ... }
     }
     ```

     위 코드와 같은 경우, Child 클래스는 예외의 최고 조상 클래스인 `Exception`을 던지기 때문에 조건을 충족하지 않는다.



<h2> Overloading
</h2>

오버로딩과 오버라이딩은 그 단어의 유사함으로 인해 혼동하기 쉽다. 하지만 그 개념은 확실히 다르며, 그 차이점을 아는 것이 중요합니다.

간단히 정희하면 오버로딩은 새로운 메소드를 정의하는 것입니다. 하지만 오버라이딩은 상속받은 기존의 메소드를 재정의하는 것입니다.

다음 예제는 부모 클래스인 Parent 클래스의 `display()` 메소드를 자식 클래스인 Child 클래스에서 오버라이딩과 오버로딩을 둘 다 수행하는 예제입니다.

```java
class Parent {
    void display() {System.out.println("부모 클래스의 display() 메소드입니다.")}
}
class Child extends Parent {
    // 오버라이딩된 display() 메소드
    void display() {System.out.println("자식 클래스의 display() 메소드입니다.")}
    void display(String str) {System.out.println(str);} //오버로딩된 display() 메소드
}

public class Main {
    public static void main(String[] args){
        Child ch = new Child();
        ch.display();
        ch.display("오버로딩된 display() 메소드입니다");
    }
}
// 자식 클래스의 display() 메소드입니다.
// 오버로딩된 display() 메소드입니다.
```





